{"content":"<div id=\"mainLeaderboard\" style=\"overflow:hidden;\"><!-- MainLeaderboard--> <!--<pre>main_leaderboard, all: [728,90][970,90][320,50][468,60]<\/pre>-->\n <div id=\"adngin-main_leaderboard-0\"><\/div> <!-- adspace leaderboard -->\n<\/div>\n<h1>DSA <span class=\"color_h1\">Stacks<\/span><\/h1>\n<div class=\"w3-clear nextprev\">\n<\/div>\n<hr>\n<h2>Stacks<\/h2>\n<p>A stack is a data structure that can hold many elements.<\/p>\n<script>\n  const app = Vue.createApp({\n    data() {\n      return {\n        currVal: null, \n        delay: 300,\n        dice: [],\n        bcColor: [\"#ECA24D\",\"#EFAA5A\", \"#D48A3B\", \"#EDB450\", \"#E7A048\"],\n        keyNumber: 0,\n        justClickedPop: false,\n        justClickedPush: false,\n        resultText: 'Result'\n      }\n    },\n    computed: {\n      popIsDisabled(){\n        return this.stackTooLow || this.justClickedPop;\n      },\n      pushIsDisabled(){\n        return this.stackTooHigh || this.justClickedPush;\n      },\n      stackTooHigh(){\n        if(this.dice.length >= 7){\n          return true;\n        }\n        else{\n          return false;\n        }\n      },\n      stackTooLow(){\n        if(this.dice.length <= 0){\n          return true;\n        }\n        else{\n          return false;\n        }\n      }\n    },\n    watch: {\n      delay: {\n        immediate: true,\n        handler() {\n          this.updateMoveDuration();\n        },\n      }\n    },\n    methods: {\n      updateMoveDuration() {\n        let stylesheets = document.styleSheets;\n        for (let i = 0; i < stylesheets.length; i++) {\n          let rules = stylesheets[i].cssRules || stylesheets[i].rules;\n          for (let j = 0; j < rules.length; j++) {\n            if (rules[j].selectorText === '.v-move') {\n              rules[j].style.transitionDuration = this.delay + 'ms';\n              break;\n            }\n          }\n        }\n      },\n      async stack(operation) {\n        this.currVal = '';\n        this.resultText = 'Result';\n        if(operation==='push'){\n          this.justClickedPush = true;\n          const newDie = {\n            dieNmbr: this.newRandom(),\n            keyNmbr: this.keyNumber,\n            isActive: false,\n            bcColor: 'rgb(252, 252, 113)',\n            isBorder: false,\n            isDone: false,\n            isFinished: false\n          };\n          this.dice.unshift(newDie);\n          this.dice[0].isActive = true;\n          await new Promise(resolve => setTimeout(resolve, 250));\n          this.dice[0].isActive = false;\n          this.keyNumber++;\n          this.dice[0].bcColor = this.bcColor[this.dice[0].dieNmbr];\n          this.justClickedPush = false;\n        }\n        else if(operation==='pop'){\n          this.dice[0].isActive = true;\n          this.justClickedPop = true;\n          this.dice[0].bcColor = 'rgb(252, 252, 113)';\n          this.currVal = this.dice[0].dieNmbr;\n          await new Promise(resolve => setTimeout(resolve, 150));\n          this.dice.shift();\n          await new Promise(resolve => setTimeout(resolve, 150));\n          this.justClickedPop = false;\n        }\n        else if(operation === 'peek'){\n          this.resultText = 'Top value';\n          this.dice[0].isActive = true;\n          this.dice[0].bcColor = 'rgb(252, 252, 113)';\n          await new Promise(resolve => setTimeout(resolve, 350));\n          this.currVal = this.dice[0].dieNmbr;\n          this.dice[0].bcColor = this.bcColor[this.dice[0].dieNmbr];\n          this.dice[0].isActive = false;\n        }\n        else if(operation === 'isEmpty'){\n          this.resultText = 'Is empty';\n          for(let i=0; i<this.dice.length; i++){\n            this.dice[i].isActive = true;\n            this.dice[i].bcColor = 'rgb(252, 252, 113)';\n          }\n          await new Promise(resolve => setTimeout(resolve, 350));\n          for(let i=0; i<this.dice.length; i++){\n            this.dice[i].isActive = false;\n            this.dice[i].bcColor = this.bcColor[this.dice[i].dieNmbr];\n          }\n          if(this.dice.length <= 0){\n            this.currVal = 'True';\n          }\n          else {\n            this.currVal = 'False';\n          }\n        }\n        else if(operation === 'size'){\n          this.resultText = 'Size';\n          for(let i=0; i<this.dice.length; i++){\n            this.dice[i].isActive = true;\n            this.dice[i].bcColor = 'rgb(252, 252, 113)';\n          }\n          await new Promise(resolve => setTimeout(resolve, 350));\n          for(let i=0; i<this.dice.length; i++){\n            this.dice[i].isActive = false;\n            this.dice[i].bcColor = this.bcColor[this.dice[i].dieNmbr];\n          }\n          this.currVal = this.dice.length;\n        }\n        else {\n          console.log(\"What happened??\");\n        }\n      },\n      newRandom(){\n        let rand = 5;\n        while(rand === 5){\n          rand = Math.floor((Math.random() * 5) + 1);\n        }\n        return rand;\n      },\n      addDie() {\n        const newDie = {\n          dieNmbr: this.newRandom(),\n          keyNmbr: this.keyNumber,\n          bcColor: null,\n          isActive: false,\n          isBorder: false,\n          isDone: false,\n          isFinished: false\n        };\n        newDie.bcColor = this.bcColor[newDie.dieNmbr];\n        //this.dice.splice(Math.floor(Math.random() * this.dice.length), 0, newDie);\n        //this.dice.push(newDie);\n        this.dice.splice(0, 0, newDie);\n        this.keyNumber++;\n      },\n      addDie50() {\n        this.dice = [];\n        this.currVal = null;\n        for (let i = 0; i < 4; i++) {\n          this.addDie();\n        }\n      }\n    },\n    mounted() {\n      this.addDie50();\n      this.updateMoveDuration();\n    }\n  })\n  app.mount('#vueApp')\n<\/script>\n<p>Think of a stack like a pile of pancakes.<\/p>\n<p>In a pile of pancakes, the pancakes are both added and removed from the top. So when removing a pancake, it will always be the last pancake you added. This way of organizing elements is called LIFO: Last In First Out.<\/p>\n<p>Basic operations we can do on a stack are:<\/p>\n<ul>\n <li><strong>Push: <\/strong>Adds a new element on the stack.<\/li>\n <li><strong>Pop: <\/strong>Removes and returns the top element from the stack.<\/li>\n <li><strong>Peek: <\/strong>Returns the top element on the stack.<\/li>\n <li><strong>isEmpty: <\/strong>Checks if the stack is empty.<\/li>\n <li><strong>Size: <\/strong>Finds the number of elements in the stack.<\/li>\n<\/ul>\n<p>Experiment with these basic operations in the stack animation above.<\/p>\n<p>Stacks can be implemented by using arrays or linked lists.<\/p>\n<p>Stacks can be used to implement undo mechanisms, to revert to previous states, to create algorithms for depth-first search in graphs, or for backtracking.<\/p>\n<p>Stacks are often mentioned together with Queues, which is a similar data structure described on the next page.<\/p>\n<hr>\n<h2>Stack Implementation using Arrays<\/h2>\n<p>To better understand the benefits with using arrays or linked lists to implement stacks, you should check out  that explains how arrays and linked lists are stored in memory.<\/p>\n<p>This is how it looks like when we use an array as a stack:<\/p>\n<script>\n  const app2 = Vue.createApp({\n    data() {\n    return {\n      currVal: null, \n      delay: 300,\n      dice: [],\n      bcColor: [\"transparent\",\"transparent\",\"transparent\",\"transparent\",\"transparent\",\"transparent\"],\n      keyNumber: 0,\n      justClickedPop: false,\n      justClickedPush: false,\n      resultText: 'Result'\n    }\n  },\n  computed: {\n    popIsDisabled(){\n      return this.queueTooShort || this.justClickedPop;\n    },\n    pushIsDisabled(){\n      return this.queueTooLong || this.justClickedPush;\n    },\n    queueTooLong(){\n      return this.dice.length >= 7;\n    },\n    queueTooShort(){\n      return this.dice.length <= 0;\n    }\n  },\n  watch: {\n    delay: {\n      immediate: true,\n      handler() {\n        this.updateMoveDuration();\n      },\n    }\n  },\n  methods: {\n    updateMoveDuration() {\n      let stylesheets = document.styleSheets;\n      for (let i = 0; i < stylesheets.length; i++) {\n        let rules = stylesheets[i].cssRules || stylesheets[i].rules;\n        for (let j = 0; j < rules.length; j++) {\n          if (rules[j].selectorText === '.v-move') {\n            rules[j].style.transitionDuration = this.delay + 'ms';\n            break;\n          }\n        }\n      }\n    },\n    async queue(operation) {\n      this.currVal = '';\n      this.resultText = 'Result';\n      let lastElIndex = this.dice.length-1;\n      if(operation==='push'){\n        this.justClickedPush = true;\n        const newDie = {\n          dieNmbr: this.newRandom(),\n          keyNmbr: this.keyNumber,\n          isActive: false,\n          bcColor: 'rgb(252, 252, 113)',\n        };\n        this.dice.push(newDie);\n        lastElIndex = this.dice.length-1;\n        this.dice[lastElIndex].isActive = true;\n        await new Promise(resolve => setTimeout(resolve, 500));\n        this.dice[lastElIndex].isActive = false;\n        this.keyNumber++;\n        this.dice[lastElIndex].bcColor = this.bcColor[this.dice[lastElIndex].dieNmbr-1];\n        this.justClickedPush = false;\n      }\n      else if(operation==='pop'){\n        this.dice[lastElIndex].isActive = true;\n        this.justClickedPop = true;\n        this.dice[lastElIndex].bcColor = 'rgb(252, 252, 113)';\n        await new Promise(resolve => setTimeout(resolve, 150));\n        this.currVal = this.dice[lastElIndex].dieNmbr;\n        this.dice.pop();\n        this.justClickedPop = false;\n      }\n      else if(operation === 'peek'){\n        this.resultText = 'Top value';\n        this.dice[lastElIndex].isActive = true;\n        this.dice[lastElIndex].bcColor = 'rgb(252, 252, 113)';\n        await new Promise(resolve => setTimeout(resolve, 350));\n        this.currVal = this.dice[lastElIndex].dieNmbr;\n        this.dice[lastElIndex].bcColor = this.bcColor[this.dice[lastElIndex].dieNmbr];\n        this.dice[lastElIndex].isActive = false;\n      }\n      else if(operation === 'isEmpty'){\n        this.resultText = 'Is empty';\n        for(let i=0; i<this.dice.length; i++){\n          this.dice[i].isActive = true;\n          this.dice[i].bcColor = 'rgb(252, 252, 113)';\n        }\n        await new Promise(resolve => setTimeout(resolve, 350));\n        for(let i=0; i<this.dice.length; i++){\n          this.dice[i].isActive = false;\n          this.dice[i].bcColor = this.bcColor[this.dice[i].dieNmbr];\n        }\n        if(this.dice.length <= 0){\n          this.currVal = 'True';\n        }\n        else {\n          this.currVal = 'False';\n        }\n      }\n      else if(operation === 'size'){\n        this.resultText = 'Size';\n        for(let i=0; i<this.dice.length; i++){\n          this.dice[i].isActive = true;\n          this.dice[i].bcColor = 'rgb(252, 252, 113)';\n        }\n        await new Promise(resolve => setTimeout(resolve, 350));\n        for(let i=0; i<this.dice.length; i++){\n          this.dice[i].isActive = false;\n          this.dice[i].bcColor = this.bcColor[this.dice[i].dieNmbr];\n        }\n        this.currVal = this.dice.length;\n      }\n      else {\n        console.log(\"What happened??\");\n      }\n    },\n    newRandom(){\n      let rand = 5;\n      while(rand === 5){\n        rand = Math.floor((Math.random() * 5) + 1);\n      }\n      return rand;\n    },\n    addDie() {\n      const newDie = {\n        dieNmbr: this.newRandom(),\n        keyNmbr: this.keyNumber,\n        bcColor: null,\n        isActive: false,\n      };\n      newDie.bcColor = this.bcColor[newDie.dieNmbr-1];\n      //this.dice.splice(Math.floor(Math.random() * this.dice.length), 0, newDie);\n      //this.dice.push(newDie);\n      this.dice.splice(0, 0, newDie);\n      this.keyNumber++;\n    },\n    addDie50() {\n      this.dice = [];\n      this.currVal = null;\n      for (let i = 0; i < 4; i++) {\n        this.addDie();\n      }\n    }\n  },\n  mounted() {\n    this.addDie50();\n    this.updateMoveDuration();\n  }\n  })\n  app2.mount('#vueApp2')\n<\/script>\n<p>Reasons to implement stacks using arrays:<\/p>\n<ul>\n <li><strong>Memory Efficient: <\/strong>Array elements do not hold the next elements address like linked list nodes do.<\/li>\n <li><strong>Easier to implement and understand: <\/strong>Using arrays to implement stacks require less code than using linked lists, and for this reason it is typically easier to understand as well.<\/li>\n<\/ul>\n<p>A reason for <strong>not<\/strong> using arrays to implement stacks:<\/p>\n<ul>\n <li><strong>Fixed size: <\/strong>An array occupies a fixed part of the memory. This means that it could take up more memory than needed, or if the array fills up, it cannot hold more elements.<\/li>\n<\/ul>\n<div class=\"w3-note\">\n <p><strong>Note:<\/strong> When using arrays in Python for this tutorial, we are really using the Python 'list' data type, but for the scope of this tutorial the 'list' data type can be used in the same way as an array. Learn more about Python lists .<\/p>\n<\/div>\n<p>Since Python lists has good support for functionality needed to implement stacks, we start with creating a stack and do stack operations with just a few lines like this:<\/p>\n<div class=\"w3-example\">\n <h3>Example<\/h3>\n <p>Python:<\/p>\n <pre class=\"language-python notranslate w3-white\"><code>stack = []\n\n# Push\nstack.append('A')\nstack.append('B')\nstack.append('C')\nprint(\"Stack: \", stack)\n\n# Pop\nelement = stack.pop()\nprint(\"Pop: \", element)\n\n# Peek\ntopElement = stack[-1]\nprint(\"Peek: \", topElement)\n\n# isEmpty\nisEmpty = not bool(stack)\nprint(\"isEmpty: \", isEmpty)\n\n# Size\nprint(\"Size: \",len(stack))<\/code><\/pre>\n<\/div>\n<p>But to explicitly create a data structure for stacks, with basic operations, we should create a stack class instead. This way of creating stacks in Python is also more similar to how stacks can be created in other programming languages like C and Java.<\/p>\n<div class=\"w3-example\">\n <h3>Example<\/h3>\n <p>Python:<\/p>\n <pre class=\"language-python notranslate w3-white\"><code>class Stack:\n    def __init__(self):\n        self.stack = []\n    \n    def push(self, element):\n        self.stack.append(element)\n    \n    def pop(self):\n        if self.isEmpty():\n            return \"Stack is empty\"\n        return self.stack.pop()\n    \n    def peek(self):\n        if self.isEmpty():\n            return \"Stack is empty\"\n        return self.stack[-1]\n    \n    def isEmpty(self):\n        return len(self.stack) == 0\n    \n    def size(self):\n        return len(self.stack)\n\n# Create a stack\nmyStack = Stack()\n\nmyStack.push('A')\nmyStack.push('B')\nmyStack.push('C')\nprint(\"Stack: \", myStack.stack)\n\nprint(\"Pop: \", myStack.pop())\n\nprint(\"Peek: \", myStack.peek())\n\nprint(\"isEmpty: \", myStack.isEmpty())\n\nprint(\"Size: \", myStack.size())<\/code><\/pre>\n<\/div>\n<hr>\n<h2>Stack Implementation using Linked Lists<\/h2>\n<p>A reason for using linked lists to implement stacks:<\/p>\n<ul>\n <li><strong>Dynamic size: <\/strong>The stack can grow and shrink dynamically, unlike with arrays.<\/li>\n<\/ul>\n<p>Reasons for <strong>not<\/strong> using linked lists to implement stacks:<\/p>\n<ul>\n <li><strong>Extra memory: <\/strong>Each stack element must contain the address to the next element (the next linked list node).<\/li>\n <li><strong>Readability: <\/strong>The code might be harder to read and write for some because it is longer and more complex.<\/li>\n<\/ul>\n<p>This is how a stack can be implemented using a linked list.<\/p>\n<div class=\"w3-example\">\n <h3>Example<\/h3>\n <p>Python:<\/p>\n <pre class=\"language-python notranslate w3-white\"><code>class Node:\n    def __init__(self, value):\n        self.value = value\n        self.next = None\n\nclass Stack:\n    def __init__(self):\n        self.head = None\n        self.size = 0\n    \n    def push(self, value):\n        new_node = Node(value)\n        if self.head:\n            new_node.next = self.head\n        self.head = new_node\n        self.size += 1\n    \n    def pop(self):\n        if self.isEmpty():\n            return \"Stack is empty\"\n        popped_node = self.head\n        self.head = self.head.next\n        self.size -= 1\n        return popped_node.value\n    \n    def peek(self):\n        if self.isEmpty():\n            return \"Stack is empty\"\n        return self.head.value\n    \n    def isEmpty(self):\n        return self.size == 0\n    \n    def stackSize(self):\n        return self.size\n\nmyStack = Stack()\nmyStack.push('A')\nmyStack.push('B')\nmyStack.push('C')\n\nprint(\"Pop: \", myStack.pop())\nprint(\"Peek: \", myStack.peek())\nprint(\"isEmpty: \", myStack.isEmpty())\nprint(\"Size: \", myStack.stackSize())<\/code><\/pre>\n<\/div>\n<hr>\n<div>\n<\/div>\n<hr> <br>\n<div class=\"w3-clear nextprev\">\n<\/div>"}