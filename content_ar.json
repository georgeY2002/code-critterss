{
    "content": "<div id=\"mainLeaderboard\" style=\"overflow:hidden;\"><!-- MainLeaderboard--><!--<pre>main_leaderboard, all: [728,90][970,90][320,50][468,60]</pre>-->\n <div id=\"adngin-main_leaderboard-0\"></div> <!-- adspace leaderboard -->\n</div>\n<h1>هياكل البيانات <span class=\"color_h1\">الستاك</span></h1>\n<div class=\"w3-clear nextprev\">\n</div>\n<hr>\n<h2>الستاك (Stacks)</h2>\n<p>الستاك هي بنية بيانات يمكنها الاحتفاظ بالعديد من العناصر.</p>\n<script>\n  // محتوى السكريبت يبقى كما هو، لا حاجة لترجمته\n</script>\n<p>فكر في الستاك كمجموعة من الفطائر المتراكمة.</p>\n<p>في مجموعة الفطائر، تُضاف الفطائر وتُزال من الأعلى. لذا عند إزالة فطيرة، ستكون دائمًا آخر فطيرة أضفتها. هذا الأسلوب في تنظيم العناصر يسمى LIFO: Last In First Out (الأخير يدخل أولاً يخرج).</p>\n<p>العمليات الأساسية التي يمكننا القيام بها على الستاك هي:</p>\n<ul>\n <li><strong>Push (إدراج): </strong>إضافة عنصر جديد إلى الستاك.</li>\n <li><strong>Pop (إزالة): </strong>إزالة وإرجاع العنصر العلوي من الستاك.</li>\n <li><strong>Peek (نظرة سريعة): </strong>إرجاع العنصر العلوي في الستاك دون إزالته.</li>\n <li><strong>isEmpty (هل هو فارغ): </strong>التحقق مما إذا كان الستاك فارغًا.</li>\n <li><strong>Size (الحجم): </strong>إيجاد عدد العناصر في الستاك.</li>\n</ul>\n<p>جرب هذه العمليات الأساسية في الرسوم المتحركة للستاك أعلاه.</p>\n<p>يمكن تنفيذ الستاك باستخدام المصفوفات أو القوائم المرتبطة.</p>\n<p>يمكن استخدام الستاك لتنفيذ آليات التراجع (undo)، للعودة إلى الحالات السابقة، لإنشاء خوارزميات للبحث المتعمق في الرسوم البيانية، أو للتراجع (backtracking).</p>\n<p>غالبًا ما يتم ذكر الستاك مع الطوابير (Queues)، وهي بنية بيانات مشابهة سيتم وصفها في الصفحة التالية.</p>\n<hr>\n<h2>تنفيذ الستاك باستخدام المصفوفات</h2>\n<p>لفهم أفضل لمزايا استخدام المصفوفات أو القوائم المرتبطة لتنفيذ الستاك، يجب عليك مراجعة الشرح حول كيفية تخزين المصفوفات والقوائم المرتبطة في الذاكرة.</p>\n<p>هذا هو شكل الستاك عند استخدام المصفوفة:</p>\n<script>\n  // محتوى السكريبت يبقى كما هو، لا حاجة لترجمته\n</script>\n<p>أسباب تنفيذ الستاك باستخدام المصفوفات:</p>\n<ul>\n <li><strong>كفاءة الذاكرة: </strong>عناصر المصفوفة لا تحتوي على عنوان العنصر التالي مثل عقد القوائم المرتبطة.</li>\n <li><strong>أسهل في التنفيذ والفهم: </strong>استخدام المصفوفات لتنفيذ الستاك يتطلب كودًا أقل من استخدام القوائم المرتبطة، ولذا يكون أسهل في الفهم أيضًا.</li>\n</ul>\n<p>سبب <strong>عدم</strong> استخدام المصفوفات لتنفيذ الستاك:</p>\n<ul>\n <li><strong>حجم ثابت: </strong>تشغل المصفوفة جزءًا ثابتًا من الذاكرة. هذا يعني أنها قد تأخذ مساحة أكثر من المطلوبة، أو إذا امتلأت المصفوفة، لا يمكنها احتواء المزيد من العناصر.</li>\n</ul>\n<div class=\"w3-note\">\n <p><strong>ملاحظة:</strong> عند استخدام المصفوفات في بايثون لهذا الشرح، نحن نستخدم في الواقع نوع البيانات 'list' في بايثون، ولكن لمدى هذا الشرح يمكن استخدام نوع البيانات 'list' بنفس طريقة المصفوفة. تعلم المزيد عن قوائم بايثون.</p>\n</div>\n<p>نظرًا لأن قوائم بايثون تدعم بشكل جيد الوظائف اللازمة لتنفيذ الستاك، نبدأ بإنشاء ستاك وتنفيذ العمليات عليه ببضع سطور فقط كما يلي:</p>\n<div class=\"w3-example\">\n <h3>مثال</h3>\n <p>بايثون:</p>\n <pre class=\"language-python notranslate w3-white\"><code>stack = []\n\n# Push\nstack.append('A')\nstack.append('B')\nstack.append('C')\nprint(\"Stack: \", stack)\n\n# Pop\nelement = stack.pop()\nprint(\"Pop: \", element)\n\n# Peek\ntopElement = stack[-1]\nprint(\"Peek: \", topElement)\n\n# isEmpty\nisEmpty = not bool(stack)\nprint(\"isEmpty: \", isEmpty)\n\n# Size\nprint(\"Size: \",len(stack))</code></pre>\n</div>\n<p>ولكن لإنشاء بنية بيانات للستاك بشكل صريح، مع العمليات الأساسية، يجب علينا إنشاء صنف (class) للستاك بدلاً من ذلك. هذه الطريقة في إنشاء الستاك في بايثون تشبه أيضًا كيفية إنشاء الستاك في لغات برمجة أخرى مثل C وJava.</p>\n<div class=\"w3-example\">\n <h3>مثال</h3>\n <p>بايثون:</p>\n <pre class=\"language-python notranslate w3-white\"><code>class Stack:\n    def __init__(self):\n        self.stack = []\n    \n    def push(self, element):\n        self.stack.append(element)\n    \n    def pop(self):\n        if self.isEmpty():\n            return \"Stack is empty\"\n        return self.stack.pop()\n    \n    def peek(self):\n        if self.isEmpty():\n            return \"Stack is empty\"\n        return self.stack[-1]\n    \n    def isEmpty(self):\n        return len(self.stack) == 0\n    \n    def size(self):\n        return len(self.stack)\n\n# إنشاء ستاك\nmyStack = Stack()\n\nmyStack.push('A')\nmyStack.push('B')\nmyStack.push('C')\nprint(\"Stack: \", myStack.stack)\n\nprint(\"Pop: \", myStack.pop())\n\nprint(\"Peek: \", myStack.peek())\n\nprint(\"isEmpty: \", myStack.isEmpty())\n\nprint(\"Size: \", myStack.size())</code></pre>\n</div>\n<hr>\n<h2>تنفيذ الستاك باستخدام القوائم المرتبطة</h2>\n<p>سبب استخدام القوائم المرتبطة لتنفيذ الستاك:</p>\n<ul>\n <li><strong>حجم ديناميكي: </strong>يمكن للستاك أن ينمو ويتقلص ديناميكيًا، على عكس المصفوفات.</li>\n</ul>\n<p>أسباب <strong>عدم</strong> استخدام القوائم المرتبطة لتنفيذ الستاك:</p>\n<ul>\n <li><strong>ذاكرة إضافية: </strong>يجب أن يحتوي كل عنصر في الستاك على عنوان العنصر التالي (العقدة التالية في القائمة المرتبطة).</li>\n <li><strong>قابلية القراءة: </strong>قد يكون الكود أصعب في القراءة والكتابة لبعض الأشخاص لأنه أطول وأكثر تعقيدًا.</li>\n</ul>\n<p>هذا هو شكل الستاك عند استخدام قائمة مرتبطة:</p>\n<div class=\"w3-example\">\n <h3>مثال</h3>\n <p>بايثون:</p>\n <pre class=\"language-python notranslate w3-white\"><code>class Node:\n    def __init__(self, value):\n        self.value = value\n        self.next = None\n\nclass Stack:\n    def __init__(self):\n        self.head = None\n        self.size = 0\n    \n    def push(self, value):\n        new_node = Node(value)\n        if self.head:\n            new_node.next = self.head\n        self.head = new_node\n        self.size += 1\n    \n    def pop(self):\n        if self.isEmpty():\n            return \"Stack is empty\"\n        popped_node = self.head\n        self.head = self.head.next\n        self.size -= 1\n        return popped_node.value\n    \n    def peek(self):\n        if self.isEmpty():\n            return \"Stack is empty\"\n        return self.head.value\n    \n    def isEmpty(self):\n        return self.size == 0\n    \n    def stackSize(self):\n        return self.size\n\nmyStack = Stack()\nmyStack.push('A')\nmyStack.push('B')\nmyStack.push('C')\n\nprint(\"Pop: \", myStack.pop())\nprint(\"Peek: \", myStack.peek())\nprint(\"isEmpty: \", myStack.isEmpty())\nprint(\"Size: \", myStack.stackSize())</code></pre>\n</div>\n<hr>\n<div>\n</div>\n<hr> <br>\n<div class=\"w3-clear nextprev\">\n</div>"
  }
  